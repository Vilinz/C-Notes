# 变量和基本内置类型

## 类型

##### 静态数据类型语言和动态类型语言

C++是一种静态类型语言，类型的检查发生在编译时，所以编译器必须知道程序中每一个变量对应的数据类型。而像Smalltalk和Python等是在运行时检查数据类型的。

##### 几种基本内置类型

C++定义了一套包括算术类型和空类型在内的两大类基本数据类型，算术类型包括字符，整型，布尔型和浮点型，空类型不对应具体的值。数据类型决定了程序当中数据和操作的意义。

##### 类型的大小

算术类型的尺寸在不同机器对应不同的大小。

##### 带符号类型和无符号类型

带符号类型表示正数，负数或0，无符号类型表示大于等于0的数。int，short，long，long long都是带符号的，可以在他们前面加上unsigned 得到无符号类型。

##### 无符号与有符号类型混用

切勿混用无符号和有符号类型，这样操作往往会出现异常的情况，如下

```C++
int a = -1;
unsigned int b = 1;
cout << a*b << endl;
// 4294967295
```

##### 字面量

形如42的值被叫做字面值常量，通过加前缀0x或者0开头可以选择进制，浮点值的字面量用E或者e表示，字符字面量用''表示，字符串字面量用“”表示。

除此以外，可以通过添加前缀或者后缀指定字面量的类型。

```c++
L'a'
u8"hi!"
42ULL
3.1415L
```

##### 转义序列

```
\n 换行符
\t 制表退格
\a 报警符
...
```

## 变量

变量提供一个具名，可供程序操作的存储空间，每个变量有其类型，类型决定了变量占用的存储空间的大小。

##### 初始化和赋值

要严格区分开初始化和赋值操作，初始化是创建变量时赋予一个初始值，而赋值是把当前值擦除用新值代替。

C++有多种不同的初始化形式，

```c++
int a = 0;
int a = {0}; //C++ 11列表初始化
int a{0}; //C++ 11
int a(0);
```

区别是，如果我们采用列表初始化的时候，当存在值丢失信息的风险的时候，编译器会报错。

```c++
int a = 0.1; //可以执行
int b{ 0.1 }; //报错
```

有时候如果我们没有显式初始化内置变量，编译器可能会帮我们初始化，如果变量在任何函数体外，他将被初始化为0；如果是函数体内部的变量则不会被初始化。任何访问未初始化值得操作将产生错误。

```c++
int a;
int main() {
	int b;
	cout << a << endl; //0
	// cout << b << endl; //错误
	return 0;
}
```

除内置类型外，绝大多数类支持无须显式初始化而定义对象。

为保证程序安全，建议初始化每个内置类型得变量。

##### 声明和定义

分离式编译：运行将程序分割为若干个文件，每个文件独立编译。

为了支持分离式编译，C++将声明和定义区分开来，声明使变量为程序所知，而定义创建与名字关联得实体。声明仅仅规定的变量的类型和名字，除此之外，定义还申请了存储空间。变量可以声明多次，但只能定义一次。

```C++
extern int a; //声明了变量
int b; //定义了变量
extern int c = 1; //定义了变量
```

在函数体内部，如果试图初始化一个由extern关键字标记的变量，将出现错误。

```c++
// help.h
#pragma once
int globalA = 1;
```

```c++
int main() {
	extern int globalA = 2;
	cout << globalA << endl;
	// cout << b << endl;
	return 0;
} //出错

extern int globalA = 2;
int main() {
	cout << globalA << endl;
	// cout << b << endl;
	return 0;
}// 出错，重定义
// 注释掉help.h后正常
```

##### 标识符

由字母，数字和下划线组成，其中必须以字母或者下划线开头，对大小写敏感。

##### 作用域

C++作用域以花括号分割。内层作用域可以使用外侧作用域，当内层作用域重定义时不影响外层作用域。

```c++
int a = 1;
{
    int a = 0;
    cout << a << endl; //0
}
cout << a << endl; //1
```

## 复合类型

两种主要的复合类型，分别是引用和指针。

引用就是为对象起了另外一个名字，其实跟我们理解的绑定差不多，通过引用可以改变原值，但引用本身不是对象，引用必须被初始化，同时一个对象可以绑定多个引用。

```c++
int a = 1024;
int &b = a;
// int &c; //报错
// int &d = 10; //错误，引用的初始值是对象
```

指针与引用类似，但指针是一个对象，指针存放对象的地址，通过取地址符&；

可以通过几种方式产生空指针，空指针不指向任何对象，

```c++
int *p1 = nullptr; //C++11标准
int *p2 = 0;
int *p3 = NULL; //NULL是预处理变量，预处理器是运行于编译过程之前的一段程序
```

注意：使用未经初始化的指针是引发运行错误的重要原因。

## const限定符

用const定义的变量的值不能被改变，所以必须被初始化。

```c++
const int i = get_size(); //运行时初始化
const int j = 42; //编译时初始化
const int k; //错误
```

const机制是在编译过程中把用到该变量的地方都替换成对应的值。在默认情况，const仅在文件内有效，当多个文件出现同名const变量时，其实相当于在不同文件当中分别定义独立的变量。但有时候我们确实需要在多个文件共享一个const'变量，我们可以对于变量不管是声明还是定义都添加extern关键字。

##### const的引用

常量的引用(常量引用)不能被用作修改它所绑定的对象。

```c++
const int ci = 1024;
const int &r1 = ci;
r1 = 42; //错误，不能通过r1改变ci
int &r2 = ci; //错误
```

允许一个常量引用绑定非常量的对象，并且可以通过其他非常量引用改变对象的值。

##### 指针和const

指向常量的指针不能用于改变其所指对象的值，要想存放常量对象的地址，只能使用指向常量的指针。

```c++
const double pi = 3.14;
double *ptr = &p1; //错误
const double *cptr = &pi; //正确
*cptr = 42; //错误
double dval = 3.14;
cptr = &dval; //正确，不能通过cptr改变dval
```

##### constexpr

常量表达式是指值不会改变并且在编译过程就能得到计算结果的表达式。在C++11中，通过将变量声明为constexpr类型来检查变量的值是否为常量表达式。但constexpr用到的类型必须有所限制，算术类型，引用和指针都属于，但类Sales_item，IO库，string类型不属于字面值类型。

## 处理类型

typedef关键字和=都可以使用类型别名。

```c++
typedef double wages;
using SI = Sales_item;
```

当类型是复合类型时慎重使用别名

```c++
typedef char *pstring;
const pstring cstr = 0; //cstr是指向char的常量指针
cost pstring *ps; //ps是一个指针，它的对象是指向char的常量指针
```

##### auto类型说明符

C++11新标准引入auto类型说明符，让编译器替我们去分析表达式所属的类型，所以auto变量必须有初始值。

##### decltype

C++11新标准，选择并返回操作数的数据类型

```c++
int func() {
	return 1;
}

int main() {
	decltype(func()) a = func();
	cout << a << endl;
	return 0;
}
```

这时编译器并不实际调用函数func，而是当调用发生时的返回值类型作为a的类型。

##头文件
#####头文件保护符
可以有效防止重复包含的发生，在这里定义的变量称为预处理变量，而预处理器是在编译之前执行的一段程序，所以这个过程的检查发生在编译之前。
```c++
#ifndef NAME_H
#define NAME_H

#endif
```
