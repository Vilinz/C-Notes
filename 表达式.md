# 表达式
## 左值右值
C++的表达式要不是右值，要不就是左值。
当一个对象被用作右值的时候，用的是对象的值；当对象被用作左值的时候，用的是对象在内存中的位置。
不同运算符对运算对象的要求不一样，有的需要左值运算对象，有的需要右值运算对象；返回值也有差异，有的得到左值结果，有的得到右值结果。下面几种情况用到左值
- 赋值运算符需要左值作为左侧对象。
- 取地址符作用于一个左值运算对象。
- 内置解引用运算符，下标运算符，迭代器解引用运算符，string和vector的下标运算符的求值结果都是左值。
- 内置类型和迭代器的递增递减运算符作用于左值运算对象，其前置版本所得到的结果也是左值。
## 求值顺序
```c++
int i = 0;
cout << i << " " << ++i << endl; //i的值不可预知，看编译器的解析
```
一般的运算符的优先级只是规定了运算对象的组合方式，但是没有说明运算对象按照什么顺序求值。有四种运算符规定了运算对象的求值顺序
```c++
|| //逻辑或
&& //逻辑与
?: //条件
, //逗号
```
## 算术运算符
## 逻辑和关系运算符
短路求值：当左侧运算对象无法确定表达式的结果才会计算右侧运算对象的值。
## 赋值运算符
赋值运算符的左侧运算对象必须是一个可修改的左值。
赋值运算满足右结合。
```c++
int ival, jval;
ival = jval = 0; //都初始化为0
```
## 递增和递减运算符
递增和递减运算符有前置版本和后置版本，都作用于左值对象。
## 成员访问运算符
## 条件运算符
相当于if-else逻辑
```c++
cond ? expr1 : expr2;
```
## 位运算符
作用于整数类型的运算对象，并把运算对象看成是二进制位的集合。
bitset标准库类型。
如果运算对象是“小整型”，他的值会被自动提升成较大的整数类型。带符号的运算对象如何进行处理依赖于机器。
```c++
unsigned char bits = 0233; //bits提升成int类型，然后向左移动8位。
```
## sizeof运算符
返回一条表达式或者一个类型名字所占是字节数，得到的是一个size_t类型的常量表达式。
```c++
sizeof (type)
sizeof expr
```
## 逗号运算符
规定了运算对象求值的顺序，对于逗号运算符来说，首先对左侧的表达式求值，然后将求值结果丢弃掉。逗号运算符真正的结果是右侧表达式的值。
## 类型转换
##### 隐式类型转换
类型转换自动执行，无须程序员介入。
```c++
int ival = 3.541 + 3;
```
何时发生
- 比int类型小的整型值首先提升为较大的整数类型。
- 在条件中，非布尔值转换成布尔类型。
- 初始化过程中，初始值转换成变量的类型；在赋值语句中，右侧运算对象转换成左侧运算对象的类型。
- 如果算术运算或者关系运算的运算对象有多种类型，需要转换成同一种类型。
- 函数调用也会发生类型转换。
##### 显式转换（强制类型转换）
- 命名的强制类型转换
```c++
cast-name<type>(expression)
```
其中cast-name是static_cast, dynamic_cast, const_cast, reinterpret_cast中的一种。
**static_cast**
只要不包含底层const，都可以使用static_cast进行强制类型转换，如
```c++
double slope = static_cast<double>(j) / i;
```
当我们试图将较大的算术类型赋值给较小的类型，编译器会给出警告信息；但当我们执行了显式的类型转换后，警告信息就会被关闭。
static_cast对于编译器无法自动执行的类型转换也非常有用，例如我们可以找回存在于void*的指针的值
```c++
double d = 2.90;
void *p = &d;
double *dp = static_cast<double*>(p);
```
**const_cast**
const_cast只能改变运算对象的底层const。
```c++
const char* pc = "asd\0";
cout << pc << endl;
char* p1 = const_cast<char*>(pc);
pc = "dfe\0";
cout << pc << p1 << endl;
```
我们可以通过pc修改对象但不能通过p1修改对象的值。
**reinterpret_cast**
##### 旧式的强制类型转换
```c++
type(expr);
(type) expr;
```
